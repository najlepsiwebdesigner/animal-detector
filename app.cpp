//opencv
#include <opencv2/highgui/highgui.hpp>
#include "opencv2/imgproc/imgproc.hpp"
#include <opencv2/video/background_segm.hpp>
//C
#include <stdio.h>
#include <cmath>
//C++
#include <iostream>
#include <sstream>

using namespace cv;
using namespace std;

//global variables
Mat frame; //current frame
Mat fgMaskMOG; //fg mask generated by MOG method
//Mat fgMaskMOG2; //fg mask fg mask generated by MOG2 method
Ptr<BackgroundSubtractor> pMOG; //MOG Background subtractor
Ptr<BackgroundSubtractor> pMOG2; //MOG2 Background subtractor
int keyboard;

// filtering objects
     Mat tempImage;
     Mat motionImage;
     Mat trajectoryImage;
     // Mat dilated;
int prevX;
int prevY;

Point prevPoint;
int totalPath;

//function declarations
void help();
void processVideo(char* videoFilename);
void processImages(char* firstFrameFilename);

void help()
{
  cout
  << "--------------------------------------------------------------------------"  << endl
  << "This program shows how to use background subtraction methods provided by "   << endl
  << " OpenCV. You can process both videos (-vid) and images (-img)."              << endl
                                                                                   << endl
  << "Usage:"                                                                      << endl
  << "./bs {-vid <video filename>|-img <image filename>}"                          << endl
  << "for example: ./bs -vid video.avi"                                            << endl
  << "or: ./bs -img /data/images/1.png"                                            << endl
  << "--------------------------------------------------------------------------"  << endl
  << endl;
}

int main(int argc, char* argv[])
{
  //print help information
  help();


trajectoryImage = Mat::zeros( 576, 768, CV_8UC3 );

  //check for the input parameter correctness
  if(argc != 3) {
    cerr <<"Incorret input list" << endl;
    cerr <<"exiting..." << endl;
    return EXIT_FAILURE;
  }

  //create GUI windows
  namedWindow("Frame");
  namedWindow("FG Mask MOG");
  // namedWindow("trajectory");
  //namedWindow("FG Mask MOG 2");

  //create Background Subtractor objects
  pMOG = createBackgroundSubtractorMOG(); //MOG approach
  pMOG2 = createBackgroundSubtractorMOG2(); //MOG2 approach

  if(strcmp(argv[1], "-vid") == 0) {
    //input data coming from a video
    processVideo(argv[2]);
  }
  else if(strcmp(argv[1], "-img") == 0) {
    //input data coming from a sequence of images
    processImages(argv[2]);
  }
  else {
    //error in reading input parameters
    cerr <<"Please, check the input parameters." << endl;
    cerr <<"Exiting..." << endl;
    return EXIT_FAILURE;
  }
  //destroy GUI windows
  destroyAllWindows();
  return EXIT_SUCCESS;
}

void processVideo(char* videoFilename) {
  //create the capture object
  VideoCapture capture(videoFilename);
  if(!capture.isOpened()){
    //error in opening the video input
    cerr << "Unable to open video file: " << videoFilename << endl;
    exit(EXIT_FAILURE);
  }

  // define positions array
  vector<Point> points;

  // int numberOfFrames = 0;

  //read input data. ESC or 'q' for quitting
  while( (char)keyboard != 'q' && (char)keyboard != 27 ){

    //read the current frame
    if(!capture.read(frame)) {
      cerr << "Total pig path is:" << totalPath << endl;
      cerr << "Unable to read next frame." << endl;
      cerr << "Exiting..." << endl;
      exit(EXIT_FAILURE);
    }

    // numberOfFrames = numberOfFrames + 1;
    // cout << numberOfFrames;

    // try filtering of input image
    //dst = frame;
    medianBlur ( frame, tempImage, 5);
    
    //update the background model
    pMOG->apply(tempImage, fgMaskMOG);
    //pMOG2->apply(frame, fgMaskMOG2);
    //get the frame number and write it on the current frame
    stringstream ss;
    rectangle(frame, cv::Point(10, 2), cv::Point(150,20),
              cv::Scalar(255,255,255), -1);
    ss << totalPath << " pixels";//capture.get(CAP_PROP_POS_FRAMES);


    // cout << "total:" << totalPath << endl;

    string frameNumberString = ss.str();



    putText(frame, frameNumberString.c_str(), cv::Point(15, 15),
            FONT_HERSHEY_SIMPLEX, 0.5 , cv::Scalar(0,0,0));
    //show the current frame and the fg masks
    
    
    
    erode( fgMaskMOG, tempImage, Mat(Size(3,3), CV_8UC1));
    //medianBlur(eroded, dst, 5);
    dilate( tempImage, motionImage, Mat());
    medianBlur(motionImage, tempImage, 5);
    //tempImage = fgMaskMOG;
    
    int SumX = 0;
    int SumY = 0;
    int num = 0;
    int numberOfPixels = tempImage.rows * tempImage.cols;

    //if (numberOfFrames == 0) {
    //  trajectoryImage = Mat::zeros( tempImage.rows, tempImage.cols, CV_8UC3 );
    //  cout << "first frame";
    //}


    // calculate center of mass
    for(int i=0; i<tempImage.rows; i++)
		for(int j=0; j<tempImage.cols; j++) {
			int pixelval = tempImage.at<uchar>(i,j);
			
			if (pixelval == 255){
				SumX = SumX + i;
				SumY = SumY + j;
				num = num + 1;
			}
				//cout <<  pixelval << endl;
		}
		//	cout << "test" << endl;
    
    double percentage = (num*100)/numberOfPixels;
    if (percentage > 0.3){
      // cout << SumX << " " << SumY << " " << num << " " << round((double)SumX/num) << " " << round((double)SumY/num) << endl;

      // cout << (num*100)/numberOfPixels << "%";
      int x  = round((double)SumX/num);
      int y = round((double)SumY/num);


      // cout << prevY << " " << y << " "<< abs(prevY-y) << endl;

      //if (abs(prevX - x) > 10 && abs(prevY - y) > 10)
        points.push_back(Point(y,x));

      // cout << points.size() << endl;

      // circle(frame, Point(y,x),5, Scalar(0,0,255),-1); 
      // circle(trajectoryImage, Point(y,x),1, Scalar(0,0,255),-1); 

      // if (prevX != 0 && prevY != 0)
      //   line( trajectoryImage, Point( prevY, prevX ), Point(y,x), Scalar( 0, 0, 100 ),  1, 8 );

      // int length = 0;




      // if (prevX != 0 && prevY != 0)

      prevX = x;
      prevY = y;
    }  
    



    prevPoint = Point();

    // if (points.size() < 1)
      // points.erase(points.begin());
    int counter = 0;
    totalPath = 0;

    for(std::vector<Point>::iterator it = points.begin(); it != points.end(); ++it) { 
      
      if (counter != 0){
        circle(frame, *it,4, Scalar(0,0,255),-1);
        line( frame, prevPoint, *it, Scalar( 100, 0, 0 ),  2, 8 );


        totalPath = totalPath + round(sqrt(pow(prevPoint.x - (*it).x, 2) + pow(prevPoint.y - (*it).y, 2)));
        // cout << "counter " << counter <<  "Path:" << totalPath << endl;
      }

      prevPoint = *it;
      counter = counter + 1;
      // length++;
    }
  




	//SumX = SumX / num;
	//SumY = SumY / num;
	//cout << "X:" << SumX << ", Y:" << SumY << endl;
    imshow("Frame", frame);
    imshow("FG Mask MOG", tempImage);
    // imshow("trajectory", trajectoryImage);
    //imshow("FG Mask MOG 2", fgMaskMOG2);
    //get the input from the keyboard
    keyboard = waitKey( 30 );
  }
  //delete capture object
  capture.release();
}

void processImages(char* fistFrameFilename) {
  //read the first file of the sequence
  frame = imread(fistFrameFilename);
  if(!frame.data){
    //error in opening the first image
    cerr << "Unable to open first image frame: " << fistFrameFilename << endl;
    exit(EXIT_FAILURE);
  }
  //current image filename
  string fn(fistFrameFilename);
  //read input data. ESC or 'q' for quitting
  while( (char)keyboard != 'q' && (char)keyboard != 27 ){
    //update the background model
    pMOG->apply(frame, fgMaskMOG);
    //pMOG2->apply(frame, fgMaskMOG2);
    //get the frame number and write it on the current frame
    size_t index = fn.find_last_of("/");
    if(index == string::npos) {
      index = fn.find_last_of("\\");
    }
    size_t index2 = fn.find_last_of(".");
    string prefix = fn.substr(0,index+1);
    string suffix = fn.substr(index2);
    string frameNumberString = fn.substr(index+1, index2-index-1);
    istringstream iss(frameNumberString);
    int frameNumber = 0;
    iss >> frameNumber;
    rectangle(frame, cv::Point(10, 2), cv::Point(100,20),
              cv::Scalar(255,255,255), -1);
    putText(frame, frameNumberString.c_str(), cv::Point(15, 15),
            FONT_HERSHEY_SIMPLEX, 0.5 , cv::Scalar(0,0,0));
    //show the current frame and the fg masks
    imshow("Frame", frame);
    imshow("FG Mask MOG", fgMaskMOG);
    //imshow("FG Mask MOG 2", fgMaskMOG2);
    //get the input from the keyboard
    keyboard = waitKey( 30 );
    //search for the next image in the sequence
    ostringstream oss;
    oss << (frameNumber + 1);
    string nextFrameNumberString = oss.str();
    string nextFrameFilename = prefix + nextFrameNumberString + suffix;
    //read the next frame
    frame = imread(nextFrameFilename);
    if(!frame.data){
      //error in opening the next image in the sequence
      cerr << "Unable to open image frame: " << nextFrameFilename << endl;
      exit(EXIT_FAILURE);
    }
    //update the path of the current frame
    fn.assign(nextFrameFilename);
  }
}
