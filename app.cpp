//opencv
#include <opencv2/highgui/highgui.hpp>
#include "opencv2/imgproc/imgproc.hpp"
#include <opencv2/video/background_segm.hpp>
#include <opencv2/features2d/features2d.hpp>
//C
#include <stdio.h>
#include <cmath>
//C++
#include <iostream>
#include <sstream>

using namespace cv;
using namespace std;

//global variables
Mat frame; //current frame
Mat fgMaskMOG; //fg mask generated by MOG method
Ptr<BackgroundSubtractor> pMOG; //MOG Background subtractor
int keyboard;



int prevX = 0;
int prevY = 0;

Point prevPoint;
int totalPath;



// filtering objects
     Mat tempImage;
     Mat motionImage;
     // Mat trajectoryImage;
     // Mat dilated;
// int prevX;
// int prevY;

// Point prevPoint;
// int totalPath;


std::vector<std::vector<cv::Point> > contours;
std::vector<std::vector<cv::Point> > approxContours;

//function declarations
void help();
void processVideo(char* videoFilename);
void processImages(char* firstFrameFilename);

void help()
{
  cout
  << "--------------------------------------------------------------------------"  << endl
  << "This program shows how to use background subtraction methods provided by "   << endl
  << " OpenCV. You can process both videos (-vid) and images (-img)."              << endl
                                                                                   << endl
  << "Usage:"                                                                      << endl
  << "./bs {-vid <video filename>|-img <image filename>}"                          << endl
  << "for example: ./bs -vid video.avi"                                            << endl
  << "or: ./bs -img /data/images/1.png"                                            << endl
  << "--------------------------------------------------------------------------"  << endl
  << endl;
}

int main(int argc, char* argv[])
{
  //print help information
  help();

  //check for the input parameter correctness
  if(argc != 3) {
    cerr <<"Incorret input list" << endl;
    cerr <<"exiting..." << endl;
    return EXIT_FAILURE;
  }

  //create GUI windows
  namedWindow("Frame");
  namedWindow("Debug");

  //create Background Subtractor objects
  pMOG = new BackgroundSubtractorMOG(); //MOG approach
  // pMOG->set("history",2);

  if(strcmp(argv[1], "-vid") == 0) {
    //input data coming from a video
    processVideo(argv[2]);
  }
  else if(strcmp(argv[1], "-img") == 0) {
    //input data coming from a sequence of images
    processImages(argv[2]);
  }
  else {
    //error in reading input parameters
    cerr <<"Please, check the input parameters." << endl;
    cerr <<"Exiting..." << endl;
    return EXIT_FAILURE;
  }
  //destroy GUI windows
  destroyAllWindows();
  return EXIT_SUCCESS;
}






void processVideo(char* videoFilename) {
  //create the capture object
  VideoCapture capture(videoFilename);
  if(!capture.isOpened()){
    //error in opening the video input
    cerr << "Unable to open video file: " << videoFilename << endl;
    exit(EXIT_FAILURE);
  }

  // define positions array
  vector<Point> points;

  int numberOfFrames = 0;

  //read input data. ESC or 'q' for quitting
  while( (char)keyboard != 'q' && (char)keyboard != 27 ){

    //read the current frame
    if(!capture.read(frame)) {
      // cerr << "Total pig path is:" << totalPath << endl;
      cerr << "Unable to read next frame." << endl;
      cerr << "Exiting..." << endl;
      exit(EXIT_FAILURE);
    }

    numberOfFrames = numberOfFrames + 1;
    // cout << numberOfFrames;

    // try filtering of input image
    //dst = frame;
    
    medianBlur ( frame, motionImage, 5);    
    //update the background model
    pMOG->operator()(motionImage, fgMaskMOG,0.015);
    // pMOG.set("histor", 3);
    
    erode( fgMaskMOG, motionImage, Mat(Size(1,1), CV_8UC1));
    erode( fgMaskMOG, motionImage, Mat(Size(1,1), CV_8UC1));
    erode( fgMaskMOG, motionImage, Mat(Size(1,1), CV_8UC1));
    // dilate( motionImage, fgMaskMOG, Mat(Size(1,1), CV_8UC1));
    motionImage = fgMaskMOG;

    // erode( fgMaskMOG, motionImage, Mat(Size(3,3), CV_8UC1));
    // dilate( motionImage, fgMaskMOG, Mat(Size(7,7), CV_8UC1));

    // erode( fgMaskMOG, motionImage, Mat(Size(9,9), CV_8UC1));
    // dilate( motionImage, fgMaskMOG, Mat(Size(9,9), CV_8UC1));
    

    int keyPointsThreshold = 3;


    int SumX = 0;
    int SumY = 0;
    int num = 0;


    int numberOfWhitePixels = 0;

    int whitePixelsThreshold = 450;

    vector<KeyPoint> keyPoints;
    SimpleBlobDetector::Params params;
        params.minThreshold = 40;
        params.maxThreshold = 60;
        params.thresholdStep = 5;

        params.minArea = 100; 
        params.minConvexity = 0.3;
        params.minInertiaRatio = 0.01;

        params.maxArea = 8000;
        params.maxConvexity = 10;

        params.filterByColor = false;
        params.filterByCircularity = false;
     SimpleBlobDetector blobDetector( params );
     blobDetector.create("SimpleBlob");
     blobDetector.detect( fgMaskMOG, keyPoints);
     drawKeypoints( frame, keyPoints, frame, CV_RGB(0,255,0), DrawMatchesFlags::DEFAULT);




    for(int i=0; i<fgMaskMOG.rows; i++){
      for(int j=0; j<fgMaskMOG.cols; j++) {
        int pixelval = fgMaskMOG.at<uchar>(i,j);
        
        if (pixelval == 255){
          numberOfWhitePixels++;
        }
          //cout <<  pixelval << endl;
      }
    }



    if (keyPoints.size() > keyPointsThreshold && numberOfWhitePixels > whitePixelsThreshold) {
      for (int i = 0; i <keyPoints.size(); i++) {
        // cout << keyPoints[i].pt.x << " " << keyPoints[i].pt.y << " ";
          SumX = SumX + keyPoints[i].pt.x;
          SumY = SumY + keyPoints[i].pt.y;
          num = num + 1;
      }
    }


    int x  = round((double)SumX/num);
    int y = round((double)SumY/num);

    cout << "x:" << x << endl << "y:" << y << endl;
    circle(frame, Point(x,y),5, Scalar(0,0,255),-1); 





    // if (prevX != 0 && prevY != 0)
    //     line( frame, Point( prevX, prevY ), Point(x,y), Scalar( 0, 0, 100 ),  1, 8 );


 if (abs(prevX - x) > 20 && abs(prevY - y) > 20 && y > 10 && x > 10){
    points.push_back(Point(x,y));
 }


    prevPoint = Point();

    // if (points.size() < 1)
      // points.erase(points.begin());
    int counter = 0;
    totalPath = 0;

    for(std::vector<Point>::iterator it = points.begin(); it != points.end(); ++it) { 
      
      if (counter != 0){
        circle(frame, *it,4, Scalar(0,0,255),-1);
        line( frame, prevPoint, *it, Scalar( 100, 0, 0 ),  2, 8 );


        totalPath = totalPath + round(sqrt(pow(prevPoint.x - (*it).x, 2) + pow(prevPoint.y - (*it).y, 2)));
        // cout << "counter " << counter <<  "Path:" << totalPath << endl;
      }

      prevPoint = *it;
      counter = counter + 1;
      // length++;
    }



    prevX = x;
    prevY = y;


    tempImage = fgMaskMOG;
  
    imshow("Frame", frame);
    imshow("Debug", tempImage);
    //get the input from the keyboard
    keyboard = waitKey( 30 );
  }


  //delete capture object
  capture.release();
}

void processImages(char* fistFrameFilename) {
  //read the first file of the sequence
  frame = imread(fistFrameFilename);
  if(!frame.data){
    //error in opening the first image
    cerr << "Unable to open first image frame: " << fistFrameFilename << endl;
    exit(EXIT_FAILURE);
  }
  //current image filename
  string fn(fistFrameFilename);
  //read input data. ESC or 'q' for quitting
  while( (char)keyboard != 'q' && (char)keyboard != 27 ){
    //update the background model
    pMOG->operator()(frame, fgMaskMOG);
    //get the frame number and write it on the current frame
    size_t index = fn.find_last_of("/");
    if(index == string::npos) {
      index = fn.find_last_of("\\");
    }
    size_t index2 = fn.find_last_of(".");
    string prefix = fn.substr(0,index+1);
    string suffix = fn.substr(index2);
    string frameNumberString = fn.substr(index+1, index2-index-1);
    istringstream iss(frameNumberString);
    int frameNumber = 0;
    iss >> frameNumber;
    rectangle(frame, cv::Point(10, 2), cv::Point(100,20),
              cv::Scalar(255,255,255), -1);
    putText(frame, frameNumberString.c_str(), cv::Point(15, 15),
            FONT_HERSHEY_SIMPLEX, 0.5 , cv::Scalar(0,0,0));
    //show the current frame and the fg masks
    imshow("Frame", frame);
    imshow("Debug", fgMaskMOG);
    //get the input from the keyboard
    keyboard = waitKey( 30 );
    //search for the next image in the sequence
    ostringstream oss;
    oss << (frameNumber + 1);
    string nextFrameNumberString = oss.str();
    string nextFrameFilename = prefix + nextFrameNumberString + suffix;
    //read the next frame
    frame = imread(nextFrameFilename);
    if(!frame.data){
      //error in opening the next image in the sequence
      cerr << "Unable to open image frame: " << nextFrameFilename << endl;
      exit(EXIT_FAILURE);
    }
    //update the path of the current frame
    fn.assign(nextFrameFilename);
  }
}
