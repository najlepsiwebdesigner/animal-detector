//opencv
#include <opencv2/highgui/highgui.hpp>
#include "opencv2/imgproc/imgproc.hpp"
#include <opencv2/video/background_segm.hpp>
#include <opencv2/features2d/features2d.hpp>
//C
#include <stdio.h>
#include <cmath>
//C++
#include <iostream>
#include <sstream>

using namespace cv;
using namespace std;

//global variables
Mat frame; //current frame
Mat fgMaskMOG; //fg mask generated by MOG method
Ptr<BackgroundSubtractor> pMOG; //MOG Background subtractor
int keyboard;

// filtering objects
     Mat tempImage;
     Mat motionImage;
     // Mat trajectoryImage;
     // Mat dilated;
// int prevX;
// int prevY;

// Point prevPoint;
// int totalPath;


std::vector<std::vector<cv::Point> > contours;
std::vector<std::vector<cv::Point> > approxContours;

//function declarations
void help();
void processVideo(char* videoFilename);
void processImages(char* firstFrameFilename);

void help()
{
  cout
  << "--------------------------------------------------------------------------"  << endl
  << "This program shows how to use background subtraction methods provided by "   << endl
  << " OpenCV. You can process both videos (-vid) and images (-img)."              << endl
                                                                                   << endl
  << "Usage:"                                                                      << endl
  << "./bs {-vid <video filename>|-img <image filename>}"                          << endl
  << "for example: ./bs -vid video.avi"                                            << endl
  << "or: ./bs -img /data/images/1.png"                                            << endl
  << "--------------------------------------------------------------------------"  << endl
  << endl;
}

int main(int argc, char* argv[])
{
  //print help information
  help();

  //check for the input parameter correctness
  if(argc != 3) {
    cerr <<"Incorret input list" << endl;
    cerr <<"exiting..." << endl;
    return EXIT_FAILURE;
  }

  //create GUI windows
  namedWindow("Frame");
  namedWindow("Debug");

  //create Background Subtractor objects
  pMOG = new BackgroundSubtractorMOG(); //MOG approach
  // pMOG->set("history",2);

  if(strcmp(argv[1], "-vid") == 0) {
    //input data coming from a video
    processVideo(argv[2]);
  }
  else if(strcmp(argv[1], "-img") == 0) {
    //input data coming from a sequence of images
    processImages(argv[2]);
  }
  else {
    //error in reading input parameters
    cerr <<"Please, check the input parameters." << endl;
    cerr <<"Exiting..." << endl;
    return EXIT_FAILURE;
  }
  //destroy GUI windows
  destroyAllWindows();
  return EXIT_SUCCESS;
}






void processVideo(char* videoFilename) {
  //create the capture object
  VideoCapture capture(videoFilename);
  if(!capture.isOpened()){
    //error in opening the video input
    cerr << "Unable to open video file: " << videoFilename << endl;
    exit(EXIT_FAILURE);
  }

  // define positions array
  vector<Point> points;

  int numberOfFrames = 0;

  //read input data. ESC or 'q' for quitting
  while( (char)keyboard != 'q' && (char)keyboard != 27 ){

    //read the current frame
    if(!capture.read(frame)) {
      // cerr << "Total pig path is:" << totalPath << endl;
      cerr << "Unable to read next frame." << endl;
      cerr << "Exiting..." << endl;
      exit(EXIT_FAILURE);
    }

    numberOfFrames = numberOfFrames + 1;
    // cout << numberOfFrames;

    // try filtering of input image
    //dst = frame;
    
    medianBlur ( frame, motionImage, 5);    
    //update the background model
    pMOG->operator()(motionImage, fgMaskMOG,0.015);
    // pMOG.set("histor", 3);
    
    erode( fgMaskMOG, motionImage, Mat(Size(1,1), CV_8UC1));
    erode( fgMaskMOG, motionImage, Mat(Size(1,1), CV_8UC1));
    erode( fgMaskMOG, motionImage, Mat(Size(1,1), CV_8UC1));
    // dilate( motionImage, fgMaskMOG, Mat(Size(1,1), CV_8UC1));
    motionImage = fgMaskMOG;

    // erode( fgMaskMOG, motionImage, Mat(Size(3,3), CV_8UC1));
    // dilate( motionImage, fgMaskMOG, Mat(Size(7,7), CV_8UC1));

    // erode( fgMaskMOG, motionImage, Mat(Size(9,9), CV_8UC1));
    // dilate( motionImage, fgMaskMOG, Mat(Size(9,9), CV_8UC1));
    

    int SumX = 0;
    int SumY = 0;
    int num = 0;

    vector<KeyPoint> keyPoints;
    SimpleBlobDetector::Params params;
        params.minThreshold = 40;
        params.maxThreshold = 60;
        params.thresholdStep = 5;

        params.minArea = 100; 
        params.minConvexity = 0.3;
        params.minInertiaRatio = 0.01;

        params.maxArea = 8000;
        params.maxConvexity = 10;

        params.filterByColor = false;
        params.filterByCircularity = false;
     SimpleBlobDetector blobDetector( params );
     blobDetector.create("SimpleBlob");
     blobDetector.detect( fgMaskMOG, keyPoints);
     drawKeypoints( frame, keyPoints, frame, CV_RGB(0,255,0), DrawMatchesFlags::DEFAULT);


    for (int i = 0; i <keyPoints.size(); i++) {
      // cout << keyPoints[i].pt.x << " " << keyPoints[i].pt.y << " ";
        SumX = SumX + keyPoints[i].pt.x;
        SumY = SumY + keyPoints[i].pt.y;
        num = num + 1;
    }

    int x  = round((double)SumX/num);
    int y = round((double)SumY/num);

    cout << "x:" << x << endl << "y:" << y << endl;


    circle(frame, Point(x,y),5, Scalar(0,0,255),-1); 

    // cv::findContours(fgMaskMOG,contours,CV_RETR_TREE,CV_CHAIN_APPROX_SIMPLE, Point(0,0) );
    // cv::drawContours(frame,contours,-1,cv::Scalar(0,0,255),2);
    



//     vector<RotatedRect> minRect( contours.size() );

//     RNG rng(12345);
// int largest_area=0;
//  int largest_contour_index=0;
  // Rect bounding_rect;

//   for( int i = 0; i< contours.size(); i++ )
//   {
//     //  Find the area of contour
//     double a=contourArea( contours[i],false); 
//     if(a>largest_area){
//         largest_area=a;cout<<i<<" area  "<<a<<endl;
//         // Store the index of largest contour
//         largest_contour_index=i;               
//         // Find the bounding rectangle for biggest contour
//         bounding_rect=boundingRect(contours[i]);
//     }
//   }
  // bounding_rect = boundingRect(fgMaskMOG);
  // rectangle(fgMaskMOG, bounding_rect,  Scalar(0,255,0),2, 8,0);
// Scalar color = Scalar( rng.uniform(0, 255), rng.uniform(0,255), rng.uniform(0,255) );



//     for( int i = 0; i < contours.size(); i++ ){ 
//       minRect[i] = minAreaRect( Mat(contours[i]) );
//       // if( contours[i].size() > 50 ){ 
//       //   minEllipse[i] = fitEllipse( Mat(contours[i]) ); 
//       // }
//     }
//     // cv::drawContours(frame,contours,-1,cv::Scalar(0,0,255),2);
//     for( int i = 0; i< contours.size(); i++ ) {

//        double a=contourArea( contours[i],false);  //  Find the area of contour
//        if(a>largest_area){
//           largest_area=a;
//           largest_contour_index=i;                //Store the index of largest contour
//           bounding_rect=boundingRect(contours[i]); // Find the bounding rectangle for biggest contour
//        }

      
//        rectangle(frame, bounding_rect,  Scalar(0,255,0),1, 8,0);  
//       // Point2f rect_points[4]; minRect[i].points( rect_points );
//       //  for( int j = 0; j < 4; j++ )
//       //     line( frame, rect_points[j], rect_points[(j+1)%4], color, 1, 8 );
//     }


    tempImage = fgMaskMOG;

    // int SumX = 0;
    // int SumY = 0;
    // int num = 0;
    // int numberOfPixels = tempImage.rows * tempImage.cols;

    // if (numberOfFrames == 0) {
    //  trajectoryImage = Mat::zeros( tempImage.rows, tempImage.cols, CV_8UC3 );
    //  cout << "first frame";
    // }


    // calculate center of mass
    // for(int i=0; i<tempImage.rows; i++) {
  		// for(int j=0; j<tempImage.cols; j++) {
  		// 	int pixelval = tempImage.at<uchar>(i,j);
  			
  		// 	if (pixelval == 255){
  		// 		SumX = SumX + i;
  		// 		SumY = SumY + j;
  		// 		num = num + 1;
  		// 	}
  		// }
    // }
    
    // double percentage = (num*100)/numberOfPixels;
    // if (percentage > 0.3){
    //   int x  = round((double)SumX/num);
    //   int y = round((double)SumY/num);

    //   // if (abs(prevX - x) > 50 && abs(prevY - y) > 50)
    //   //   points.push_back(Point(y,x));

    //   circle(frame, Point(y,x),5, Scalar(0,0,255),-1); 

    //   prevX = x;
    //   prevY = y;
    // }  

    // prevPoint = Point();
    // int counter = 0;
    // totalPath = 0;

    // for(std::vector<Point>::iterator it = points.begin(); it != points.end(); ++it) {  
    //   if (counter != 0){
    //     circle(frame, *it,4, Scalar(0,0,255),-1);
    //     line( frame, prevPoint, *it, Scalar( 100, 0, 0 ),  2, 8 );
    //     totalPath = totalPath + round(sqrt(pow(prevPoint.x - (*it).x, 2) + pow(prevPoint.y - (*it).y, 2)));
    //   }

    //   prevPoint = *it;
    //   counter = counter + 1;
    // }
  
    imshow("Frame", frame);
    imshow("Debug", tempImage);
    //get the input from the keyboard
    keyboard = waitKey( 30 );
  }


  //delete capture object
  capture.release();
}

void processImages(char* fistFrameFilename) {
  //read the first file of the sequence
  frame = imread(fistFrameFilename);
  if(!frame.data){
    //error in opening the first image
    cerr << "Unable to open first image frame: " << fistFrameFilename << endl;
    exit(EXIT_FAILURE);
  }
  //current image filename
  string fn(fistFrameFilename);
  //read input data. ESC or 'q' for quitting
  while( (char)keyboard != 'q' && (char)keyboard != 27 ){
    //update the background model
    pMOG->operator()(frame, fgMaskMOG);
    //get the frame number and write it on the current frame
    size_t index = fn.find_last_of("/");
    if(index == string::npos) {
      index = fn.find_last_of("\\");
    }
    size_t index2 = fn.find_last_of(".");
    string prefix = fn.substr(0,index+1);
    string suffix = fn.substr(index2);
    string frameNumberString = fn.substr(index+1, index2-index-1);
    istringstream iss(frameNumberString);
    int frameNumber = 0;
    iss >> frameNumber;
    rectangle(frame, cv::Point(10, 2), cv::Point(100,20),
              cv::Scalar(255,255,255), -1);
    putText(frame, frameNumberString.c_str(), cv::Point(15, 15),
            FONT_HERSHEY_SIMPLEX, 0.5 , cv::Scalar(0,0,0));
    //show the current frame and the fg masks
    imshow("Frame", frame);
    imshow("Debug", fgMaskMOG);
    //get the input from the keyboard
    keyboard = waitKey( 30 );
    //search for the next image in the sequence
    ostringstream oss;
    oss << (frameNumber + 1);
    string nextFrameNumberString = oss.str();
    string nextFrameFilename = prefix + nextFrameNumberString + suffix;
    //read the next frame
    frame = imread(nextFrameFilename);
    if(!frame.data){
      //error in opening the next image in the sequence
      cerr << "Unable to open image frame: " << nextFrameFilename << endl;
      exit(EXIT_FAILURE);
    }
    //update the path of the current frame
    fn.assign(nextFrameFilename);
  }
}
