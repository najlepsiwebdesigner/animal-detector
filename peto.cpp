//opencv
#include <opencv2/highgui/highgui.hpp>
#include "opencv2/imgproc/imgproc.hpp"
#include <opencv2/video/background_segm.hpp>
#include <opencv2/features2d/features2d.hpp>
//C
#include <stdio.h>
#include <cmath>
//C++
#include <iostream>
#include <sstream>

using namespace cv;
using namespace std;

//global variables
Mat frame; //current frame
Mat fgMaskMOG; //fg mask generated by MOG method
Ptr<BackgroundSubtractor> pMOG; //MOG Background subtractor
int keyboard;

Point prevPoint;
Point previousPoint;


// std::vector<cv::Point> points;



// filtering objects
     Mat tempImage;
     Mat motionImage;
     // Mat trajectoryImage;
     // Mat dilated;
// int prevX;
// int prevY;

// Point prevPoint;
// int totalPath;


std::vector<std::vector<cv::Point> > contours;
std::vector<std::vector<cv::Point> > approxContours;

//function declarations
void help();
void processVideo(char* videoFilename);
void processImages(char* firstFrameFilename);

void help()
{
  cout
  << "--------------------------------------------------------------------------"  << endl
  << "This program shows how to use background subtraction methods provided by "   << endl
  << " OpenCV. You can process both videos (-vid) and images (-img)."              << endl
                                                                                   << endl
  << "Usage:"                                                                      << endl
  << "./bs {-vid <video filename>|-img <image filename>}"                          << endl
  << "for example: ./bs -vid video.avi"                                            << endl
  << "or: ./bs -img /data/images/1.png"                                            << endl
  << "--------------------------------------------------------------------------"  << endl
  << endl;
}

int main(int argc, char* argv[])
{
  //print help information
  help();

  //check for the input parameter correctness
  if(argc != 3) {
    cerr <<"Incorret input list" << endl;
    cerr <<"exiting..." << endl;
    return EXIT_FAILURE;
  }

  //create GUI windows
  namedWindow("Frame");
  namedWindow("Debug");

  //create Background Subtractor objects
  pMOG = new BackgroundSubtractorMOG(); //MOG approach
  // pMOG->set("history",2);

  if(strcmp(argv[1], "-vid") == 0) {
    //input data coming from a video
    processVideo(argv[2]);
  }
  else if(strcmp(argv[1], "-img") == 0) {
    //input data coming from a sequence of images
    processImages(argv[2]);
  }
  else {
    //error in reading input parameters
    cerr <<"Please, check the input parameters." << endl;
    cerr <<"Exiting..." << endl;
    return EXIT_FAILURE;
  }
  //destroy GUI windows
  destroyAllWindows();
  return EXIT_SUCCESS;
}






void processVideo(char* videoFilename) {
  //create the capture object
  VideoCapture capture(videoFilename);
  if(!capture.isOpened()){
    //error in opening the video input
    cerr << "Unable to open video file: " << videoFilename << endl;
    exit(EXIT_FAILURE);
  }

  // define positions array
  vector<Point> points;

  int numberOfFrames = 0;

  //read input data. ESC or 'q' for quitting
  while( (char)keyboard != 'q' && (char)keyboard != 27 ){

    //read the current frame
    if(!capture.read(frame)) {
      // cerr << "Total pig path is:" << totalPath << endl;
      cerr << "Unable to read next frame." << endl;
      cerr << "Exiting..." << endl;
      exit(EXIT_FAILURE);
    }
    rectangle(frame, Point(0,0), Point(500,17), Scalar(0,0,0), CV_FILLED);
    
    motionImage = frame.clone();
    // medianBlur ( motionImage, motionImage, 7);    
    
    //update the background model
    pMOG->operator()(motionImage, fgMaskMOG, 0.015);

    dilate( fgMaskMOG, fgMaskMOG, Mat(Size(7,7), CV_8UC1));
    erode( fgMaskMOG, fgMaskMOG, Mat(Size(7,7), CV_8UC1));
    rectangle(fgMaskMOG, Point(0,0), Point(frame.cols,17), Scalar(0,0,0), CV_FILLED);
    rectangle(fgMaskMOG, Point(0,0), Point(17,frame.rows), Scalar(0,0,0), CV_FILLED);
  
    numberOfFrames = numberOfFrames + 1;
    int numberOfWhitePixels = 0;
    int whitePixelsThreshold = 200;

    int minY = 1000;
    int maxY = 0;
    int minX = 1000;
    int maxX = 0;
    int sumX = 0;
    int sumY = 0;

    for(int i=0; i<fgMaskMOG.rows; i++){
      for(int j=0; j<fgMaskMOG.cols; j++) {
        int pixelval = fgMaskMOG.at<uchar>(i,j);
        
        if (pixelval == 255){
          numberOfWhitePixels++;

          if(minX>j) minX = j;
          if(maxX<j) maxX = j;
          if(minY>i) minY = i;
          if(maxY<i) maxY = i;

          sumX += j;
          sumY += i;
        }
      }
    }

    
    if ((char)keyboard == 's') {

      string str(videoFilename); 
      cout << str + ".jpg" << endl;
      imwrite(str + ".jpg", frame);
    } else {

      // compute center
      if (numberOfWhitePixels > whitePixelsThreshold){
        // int centerX = round(sumX/numberOfWhitePixels);// (round(sumX/numberOfWhitePixels) + int((minX+maxX)/2)) / 2;
        // int centerY = round(sumY/numberOfWhitePixels); //(round(sumY/numberOfWhitePixels) + int((minY+maxY)/2)) / 2;

        int centerX = int((minX+maxX)/2);
        int centerY = int((minY+maxY)/2);

        Point middle(centerX, centerY);

        // draw center
        circle(frame, middle,10, Scalar(0,0,255),-1);   
        // add point to collection
        points.push_back(Point(centerX, centerY));
// prevPoint = middle;
      }

      int length = 0;   
      int totalPath = 0;

      for(int i = 0; i<points.size(); i++) { 
        if (i != 0){
          length = round(sqrt(pow(previousPoint.x - points[i].x, 2) + pow(previousPoint.y - points[i].y, 2)));

// circle(frame, points[i],2, Scalar(0,0,0),-1);
// line( frame, previousPoint, points[i], Scalar( 0, 0, 255 ),  2, 8 );
          totalPath = totalPath + length;

        }
        previousPoint = points[i];
      }      
    }

    imshow("Frame", frame);
    imshow("Debug", fgMaskMOG);
  
    //get the input from the keyboard
    keyboard = waitKey( 1 );
  }


  //delete capture object
  capture.release();
}

void processImages(char* fistFrameFilename) {
  //read the first file of the sequence
  frame = imread(fistFrameFilename);
  if(!frame.data){
    //error in opening the first image
    cerr << "Unable to open first image frame: " << fistFrameFilename << endl;
    exit(EXIT_FAILURE);
  }
  //current image filename
  string fn(fistFrameFilename);
  //read input data. ESC or 'q' for quitting
  while( (char)keyboard != 'q' && (char)keyboard != 27 ){
    //update the background model
    pMOG->operator()(frame, fgMaskMOG);
    //get the frame number and write it on the current frame
    size_t index = fn.find_last_of("/");
    if(index == string::npos) {
      index = fn.find_last_of("\\");
    }
    size_t index2 = fn.find_last_of(".");
    string prefix = fn.substr(0,index+1);
    string suffix = fn.substr(index2);
    string frameNumberString = fn.substr(index+1, index2-index-1);
    istringstream iss(frameNumberString);
    int frameNumber = 0;
    iss >> frameNumber;
    rectangle(frame, cv::Point(10, 2), cv::Point(100,20),
              cv::Scalar(255,255,255), -1);
    putText(frame, frameNumberString.c_str(), cv::Point(15, 15),
            FONT_HERSHEY_SIMPLEX, 0.5 , cv::Scalar(0,0,0));
    //show the current frame and the fg masks
    imshow("Frame", frame);
    imshow("Debug", fgMaskMOG);
    //get the input from the keyboard
    keyboard = waitKey( 30 );
    //search for the next image in the sequence
    ostringstream oss;
    oss << (frameNumber + 1);
    string nextFrameNumberString = oss.str();
    string nextFrameFilename = prefix + nextFrameNumberString + suffix;
    //read the next frame
    frame = imread(nextFrameFilename);
    if(!frame.data){
      //error in opening the next image in the sequence
      cerr << "Unable to open image frame: " << nextFrameFilename << endl;
      exit(EXIT_FAILURE);
    }
    //update the path of the current frame
    fn.assign(nextFrameFilename);
  }
}
